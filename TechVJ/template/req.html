<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Buffered MKV/MP4 Player</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    video {
      width: 100%;
      max-width: 800px;
      background: #000;
    }
  </style>
</head>
<body>
  <video id="player" controls playsinline></video>
  <script>
    (async () => {
      const url = `{{file_url}}`;
      const video = document.getElementById('player');
      if (!('MediaSource' in window)) {
        // fallback to simple src
        video.src = url;
        return;
      }const mediaSource = new MediaSource();
  video.src = URL.createObjectURL(mediaSource);

  let sourceBuffer;
  // Adjust mimeCodec to match your encoding. MKV may require video/webm or video/mp4
  const mimeCodec = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
  const SEGMENT_DURATION = 10; // seconds
  const approxBitrate = 500_000; // bytes per second estimate, adjust as needed

  mediaSource.addEventListener('sourceopen', async () => {
    sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
    await fetchSegment(0);
  });

  async function fetchSegment(startSec) {
    // Calculate approximate byte range
    const startByte = Math.floor(startSec * approxBitrate);
    const endByte = Math.floor((startSec + SEGMENT_DURATION) * approxBitrate) - 1;
    const res = await fetch(url, { headers: { 'Range': `bytes=${startByte}-${endByte}` } });
    const data = await res.arrayBuffer();

    return new Promise(resolve => {
      sourceBuffer.addEventListener('updateend', () => {
        resolve();
      }, { once: true });
      sourceBuffer.appendBuffer(data);
    }).then(() => {
      video.currentTime = startSec;
      video.play();
    });
  }

  video.addEventListener('seeking', () => {
    const target = Math.max(0, video.currentTime - SEGMENT_DURATION);
    // Reset buffer
    if (mediaSource.readyState === 'open') {
      if (sourceBuffer.updating) sourceBuffer.abort();
      mediaSource.removeSourceBuffer(sourceBuffer);
      sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
      fetchSegment(target);
    }
  });
})();

  </script>
</body>
</html>
